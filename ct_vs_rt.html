<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style>

.comment { color: #999999; font-style: italic; }
.pre { color: #000099; }
.string { color: #009900; }
.char { color: #009900; }
.float { color: #996600; }
.int { color: #999900; }
.bool { color: #000000; font-weight: bold; }
.type { color: #FF6633; }
.flow { color: #FF0000; }
.keyword { color: #990000; }
.operator { color: #663300; font-weight: bold; }
.operator { color: #663300; font-weight: bold; }
pre.code {
    border: 2px solid #666;
    background-color: #F4F4F4;
    padding-left: 10px;
    padding-top: 0px;
}
code {
    border: 2px solid #d0d0d0;
    background-color: LightYellow;
    padding: 2px;
    padding-left: 10px;
    display:table;
    white-space:pre;
    margin:2px;
    margin-bottom:10px;
}

dt {
    font-weight: bold;
}
.ins {
    background-color:#A0FFA0;
}
.del {
    background-color:#FFA0A0;
    text-decoration:line-through
}    
h3 { 
	margin-bottom: 0;
}
h4 { 
	margin-bottom: 0;
}
</style>

<title>Can terse notation unify generic and object-oriented programming?</title>
</head>

<body>
<p>D1069R0<br>
Mike Spertus, Symantec<br>
<a href="mailto:mike_spertus@symantec.com">mike_spertus@symantec.com</a><br>
2018-05-20<br>
Audience: Evolution Working Group
</p>
<h1>Can terse notation unify generic and object-oriented programming?</h1>
	<h2>Abstract</h2>
	<p>C++ works best when compile-time and run-time programming are similar. For example, <tt>constexpr</tt> functions allow programs to easily move calculations back and forth between compile-time and run-time as circumstances dictate with no change in code. Similarly, terse notation hopes to reduce the notational distance between template-based compile-time dispatch and OOP-based runtime-dispatch. This paper looks at how well three different proposals for terse notation unify compile-time and run-time dispatch and examine their potential to further unify generic and object-oriented programming.  We think this is an important use case for terse notation not only for its (considerable we believe) intrinsic value, but also because terse notation is an essential component for it and not merely a notational convenience.</p>
    <p>Before proceeding with this analysis, we wish to thank Herb Sutter for detailed input as well as the many people who have contributed to terse concepts.</p>
<h2>Discussion</h2>
<p>It is well-known that generic programming and object-oriented programming can be applied to similar problems (See, for example, the discussion of containers in Bjarne Stroustrup's <a href="http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/28/slides/bjarne.pdf">Concepts for C++1y: The Challenge</a>). While both object-oriented programming and generic programming are incredibly powerful at type-based dispatching, deciding which one to use can be difficult and is very committal once made. To us, the appeal of terse notation is that it has the potential to maintain flexibility to evolve program design in this regard, which is a huge benefit, as illustrated by the following example:
	
<code>bool is_convex(Shape &amp;s) { <span class="comment">/* ... */</span> }</code>
In C++17, this object-oriented code will use virtual methods in the <tt>Shape</tt> class to determine whether a shape is <a href="https://en.wikipedia.org/wiki/Convex_set">convex</a>, but in the Concepts TS, it could equally be interpreted as a compile-time dispatch as a function template, potentially maintaining the flexibility to investigate improving performance by changing <tt>Shape</tt> to a Concept. If such a unification could be achieved, we believe it would be fantastically powerful, but of course the devil is in the details and achieving this vision is easier said than done.</p>
<p>To maintain such flexible dispatch, we think that terse notation should meet 3 goals</p>
<ol><li><b>Stable declarations: </b>
Without terse notation, changing <tt>Shape</tt> to a Concept requires making major changes to the declarations of all functions that have <tt>Shape</tt> arguments. E.g.,
<code>template&lt;typename T&gt;
bool is_convex(T &amp;s) requires Shape&lt;T&gt; { <span class="comment">/* ... */</span> }</code>
Since the programmer would have to redeclare every function in the library that accepts <tt>Shape</tt>s, this would invite errors and in practice would often be impractical, resulting in brittleness.</li>
	
<li><b>Stable interpretations:</b> Changing <tt>Shape</tt> from a class to a Concept should not change the interpretation of how functions act on the object model. For example, consider the following definition in the Concepts TS<code>bool is_smaller(Shape &amp;l, Shape &amp;r) { return l.area() &lt; r.area(); }</code>
	If <tt>Shape</tt> is a base class, then <tt>is_smaller</tt> can compare the area of a triangle and a square, but if <tt>Shape</tt> is a Concept, it will only accept shapes of the same type. Changing from run-time dispatch to compile-time dispatch should be independent of the logical behavior of the function.</li>
<li><b>Minimize code breakage:</b> It does little good to have a stable declaration and interpretation for <tt>is_convex</tt> if it needs to be completely rewritten if <tt>Shape</tt> is changed from a type to a Concept due to <em>body breakage</em> such as
<code>bool is_convex(Shape &amp;s) 
{
  Shape s2;        <span class="comment">// Ill-formed if Shape is a Concept</span>
  vector&lt;Shape&gt; v; <span class="comment">// Ill-formed if Shape is a Concept</span>
  <span class="comment">/* ... */</span>
}</code>
Likewise, flexibility may fail on the client-side when code using <tt>is_convex</tt> suffers <em>usage breakage</em> when conceptizing <tt>is_convex</tt> turns it from a function to a function template. Indeed, a common criticism of the Concepts TS is that one cannot tell whether the code such as the following is legal just by looking at the declaration of <tt>is_convex</tt>  
	<code>auto x = &amp;is_convex; // Concepts TS: Valid if Shape is a type. Ill-formed if Shape is a Concept</code>
See <a href="https://wg21.link/p0587r0">P0587R0</a> and <a href="https://wg21.link/p0696r0">P0696R0</a> for more discussion of code interpretation changes between classes and Concepts.</li>
</ol>
<p>In the rest of this paper, we look at how well several terse notation proposals support these goals. Our basic finding is that none of them are optimal on all of these goals &ldquo;as is&rdquo;. However, with some refinements, any one of the terse notations could provide excellent support all 3 goals. Note that Concepts without terse notation accomplishes none of these three goals.</p>
	
	
<h2>Concepts TS</h2>

<p>We start with the Concepts TS as a baseline</p>
<ul><li><b>Stable declarations:</b> This is the strong suit of the Concepts TS as function declarations look the same whether or not they are used with classes or Concepts.
<code>bool is_convex(Shape &amp;s); <span class="comment">// Remains valid with expected meaning whether Shape is a type or a Concept</span></code></li>
	<li><b>Stable interpretations:</b> The Concepts TS does not provide stable interpretations as shown by the <tt>is_smaller</tt> example above.
</li>
	<li><b>Minimize code breakage:</b> The Concepts TS does nothing to minimize code breakage, and is vulnerable to both usage breakage and body breakage as described above.</li></ul>
<h3>Possible refinements</h3>
<p>Stable interpretation can be addressed by switching to independent binding of function arguments. Unfortunately, as has frequently been noted, it is difficult to see any way to protect against usage breakage within the framework of the Concepts TS. Body breakage can be addressed by the same approach described for the &ldquo;minimal solution&rdquo; below.</p>

<h2>A minimal solution to the concepts syntax problems</h2>
<p>Bjarne Stroustrup's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1079r0.pdf">A minimal solution to the concepts syntax problems</a> paper addresses usage breakage by requiring that declarations using the natural syntax be preceded by the word <tt>template</tt>. 
	<code>template bool is_convex(Shape &amp;s); <span class="comment">// Shape is a Concept</span></code>
<ul><li><b>Stable declarations: </b> Unfortunately, this proposal does not provide stable declarations as changing <tt>Shape</tt> a Concept will require prefixing the declarations of all functions that use <tt>Shape</tt> with <tt>template</tt>. While this is easy to do for just the one function <tt>is_convex</tt>, in a library with many functions, switching back and forth (e.g., to investigate the tradeoffs between run-time and compile-time dispatching) will be a lot of work.</li>
<li><b>Stable interpretations:</b> This proposal provides stable interpretations through independent resolutions of arguments</li>
<li><b>Minimize code breakage: </b> This proposal addresses usage breakage as mentioned above but does not address body breakage</li></ul> 
	
<h3>Possible refinements</h3>
<p>One thing we like about this proposal is that with several refinements, it is possible to achieve a good degree of compatibility with all of the goals in this paper!</p>
	
	<p>Stable declarations can be achieved by allowing any function declaration to advertise that it has a stable declaration by preceding it by the word <tt>template</tt>, whether or not it currently has Concept arguments. <code>template bool is_convex(Shape &amp;s); <span class="comment">// Permit whether Shape is a Concept or a class</span></code> In some ways, this provides the best of both worlds. Ordinary and legacy functions are not subject to silent usage breaking as in the Concepts TS, but functions that wish to maintain flexibility as to whether their arguments are types or Concepts may do so, serving both as a declaration of intent and allowing for quick switching back and forth during the implementation phase. Such functions may not be used (through public interfaces) in ways that assume they are non-template functions, further protecting against usage breakage. 
		<code>template bool is_convex(Shape &amp;s); <span class="comment">// Permit whether Shape is a Concept or a class</span>
auto x = &amp;is_convex; <span class="comment">// Ill-formed whether Shape is a concept or a class</span></code> </p>
    <p><b>Note: </b> It seems difficult to us to provide similar protection against usage breakage in the Concepts TS (If there is no special notation for declarations, where would you note that you wish to ban such usage?) </p>
	<p><b>Bikeshed: </b>A keyword other than <tt>template</tt> may be worth considering as <tt>is_convex</tt> may or may not actually be a function template depending on whether <tt>Shape</tt> is currently a class or a Concept.</p>
<p>All that remains is to minimize body breakage. The key insight here is that the fundamental problem is that not all code that is legal for classes is legal for Concepts, so if we wish to program with the idea that some type may be replaced with a Concept in the future as the tradeoffs between run-time and compile-time dispatching evolve, we need to avoid such constructs.  Since a symbol's declaration declares whether it is a class or a concept, that is also a natural place to declare that a class may be replaced with a concept later, say with a prefix like <tt>may_become_concept</tt> (bikeshed)
<code>may_become_concept class Shape { <span class="comment">/* ... */</span> };</code>
This not only serves a valuable documentary purpose but allows us to make ill-formed code that would not work with concepts. Technically, we propose that the compiler replace all mentions of a <tt>may_become_concept</tt> class within the body of a &ldquo;<tt>template</tt>&rdquo; function with a notional concept satisfied by any type that inherits from the class. We think this is a simple way to obviate the subtle difference between classes and concepts while maintaining a good degree of (admittely not perfect) compatibility with existing code.
<code>template bool is_convex(Shape &amp;s) 
{
  Shape s2;        <span class="comment">// Proposed: Ill-formed regardless of whether Shape is a Concept or may_become_concept</span>
  vector&lt;Shape&gt; v; <span class="comment">// Proposed: Ill-formed regardless of whether Shape is a Concept or may_become_concept</span>
  Shape s3 = s;    <span class="comment">// Ok if Shape is a class or Concept</span>
   <span class="comment">// typename required below because Shape is either a concept or a class replaced by a notional concept</span>
  typename Shape::NestedType;    
  <span class="comment">/* ... */</span>
}</code></p>
<b>Notes: </b> This is only a syntactic check (as in template syntactic-analysis). Any deeper checking along the lines of C++0X concepts definition checking is far beyond the scope of this paper.
<h2>Concepts in-place syntax</h2>
<p>Herb Sutter's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0P745r0.pdf">Concepts in-place syntax</a> avoids usage breakage by requiring that changing <tt>Shape</tt> from a class to a concept requires rewriting functions that accept <tt>Shape</tt>s.
<code>bool is_convex(Shape &amp;shape);    <span class="comment">// Shape is a class</span>
bool is_convex(Shape {} &amp;shape); <span class="comment">// Shape is a Concept</span></code>
</p>
<ul><li><b>Stable declarations: </b> This proposal does not provide stable declarations as changing <tt>Shape</tt> a Concept will require modifying the declarations of all functions that use <tt>Shape</tt> arguments with <tt>{}</tt>. While this is easy to do for just the one function <tt>is_convex</tt>, in a library with many functions, switching back and forth (e.g., to investigate the tradeoffs between run-time and compile-time dispatching) will require tedious and error-prone modifications to many declarations.</li>
<li><b>Stable interpretations:</b> This proposal provides stable interpretations through independent resolutions of arguments</li>
<li><b>Minimize code breakage: </b> This proposal addresses usage breakage as mentioned above but does not address body breakage</li></ul> 
<h3>Possible refinements</h3>
This approach can also be made to achieve all of the goals of the paper. We propose that if a function declaration wishes to maintain flexibility as to whether one of its arguments is a class or a concept, it can use <tt>{}</tt> thereby gaining declaration stability while maintaing interpretation stability.
	<code>bool is_convex(Shape {} &amp;shape); <span class="comment">// Proposed: Valid whether Shape is a class or a Concept</span>
auto x = &amp;is_convex; <span class="comment">// Proposed: Ill-formed whether Shape is a class or a Concept</span></code>
Likewise, body breakage can be avoided by leveraging the advertisement of the <tt>{}</tt>.
<code>bool is_convex(Shape {} &amp;s) 
{
  Shape s2;        <span class="comment">// Proposed: Ill-formed if Shape is a class or Concept</span>
  vector&lt;Shape&gt; v; <span class="comment">// Proposed: Ill-formed regardless of whether Shape is a class or Concept</span>
  Shape s3 = s;    <span class="comment">// Ok if Shape is a class or Concept</span>
  <span class="comment">/* ... */</span>
}</code> Alternatively, the <tt>may_become_concept</tt> approach to preventing body breakage could be used, although it does not seem to integrate quite as naturally in this approach as in the &ldquo;minimal solution&rdquo; approach.
<h2>Next steps</h2>
 We are fully aware that more details (E.g., should there be special handling for an <tt>X&amp;&amp;</tt> if <tt>X</tt> is a <tt>may_become_concept</tt> class) and more substantial examples are needed to convincingly demonstrate that terse notation can be an effective tool for unifying compile-time and run-time dispatch. We intend to provide both of those in a paper for San Diego. As for the Rapperswil meeting, we do not think this should detract from voting on a terse notation as this proposal can build on any of the terse notations under consideration (Although better on the Minimal Solution and In-place Syntax than on the Concepts TS).
</body></html>