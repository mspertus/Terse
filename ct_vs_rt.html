<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style>

.comment { color: #999999; font-style: italic; }
.pre { color: #000099; }
.string { color: #009900; }
.char { color: #009900; }
.float { color: #996600; }
.int { color: #999900; }
.bool { color: #000000; font-weight: bold; }
.type { color: #FF6633; }
.flow { color: #FF0000; }
.keyword { color: #990000; }
.operator { color: #663300; font-weight: bold; }
.operator { color: #663300; font-weight: bold; }
pre.code {
    border: 2px solid #666;
    background-color: #F4F4F4;
    padding-left: 10px;
    padding-top: 0px;
}
code {
    border: 2px solid #d0d0d0;
    background-color: LightYellow;
    padding: 2px;
    padding-left: 10px;
    display:table;
    white-space:pre;
    margin:2px;
    margin-bottom:10px;
}
dt {
    font-weight: bold;
}
.ins {
    background-color:#A0FFA0;
}
.del {
    background-color:#FFA0A0;
    text-decoration:line-through
}    
h3 { 
	margin-bottom: 0;
}
h4 { 
	margin-bottom: 0;
}
</style>

<title>Can terse notation unify generic and object-oriented programming?</title>
</head>

<body>
<!--<p>DXXXX<br>
Mike Spertus, Symantec<br>
<a href="mailto:mike_spertus@symantec.com">mike_spertus@symantec.com</a><br>
2018-05-07<br>
Audience: Evolution Working Group
</p>-->
<h1>Can terse notation unify generic and object-oriented programming?</h1>
	<h2>Abstract</h2>
	<p>C++ works best when compile-time and run-time programming are similar. For example, <tt>constexpr</tt> functions allow programs to easily move a calculation between compile-time and run-time as circumstances dictate. Indeed, all proposals for terse notation make Concept-based generic programming suggestive of the familiar object-oriented polymorphism model.</p>
	<p>This paper examines how well three different proposals for terse notation unify compile-time dispatch and run-time dispatch. Fortunately, we find that any of the three terse notation proposals are capable of enabling this vision with modest refinements (described below), so this paper does not need to be tightly coupled with the rest of the debate over which terse notation to use.</p>
<h2>Discussion</h2>
<p>C++ can perform polymorphic dispatch both at run-time via object-oriented programming and at compile-time via generic programming. While both object-oriented programming and generic programming are incredibly powerful, the decision of which one to use can be difficult and is very committal once made. To us, the appeal of terse notation is that it helps maintains flexibility to evolve program design in this regard, which is a huge benefit, as illustrated by the following example:
<code>bool is_convex(Shape &amp;s) { <span class="comment">/* ... */</span> }</code>
In C++17, this object-oriented code will use virtual methods in the <tt>Shape</tt> class to determine whether a shape is <a href="https://en.wikipedia.org/wiki/Convex_set">convex</a>. As time goes on, it may well happen, as is often the case (esp. in what looks to be a computation-intensive geometry library), that it is desired to investigate improving performance by changing <tt>Shape</tt> to a Concept making <tt>is_convex</tt> a function template that dispatches at compile-time.</p>
<p>We think that terse notation should achieve 3 goals to enable such flexible dispatch</p>
<ol><li><b>Stable declarations: </b>
Without terse notation, changing <tt>Shape</tt> to a Concept requires making major changes to the declarations of all functions that have <tt>Shape</tt> arguments. E.g.,
<code>template&lt;typename T&gt;
bool is_convex(T &amp;s) requires Shape&lt;T&gt; { <span class="comment">/* ... */</span> }</code>
Since the programmer would have to redeclare every function in the library that accepts <tt>Shape</tt>s, this would invite errors and in practice would often be impractical, resulting in brittleness.</li>
	
<li><b>Stable interpretations:</b> Changing <tt>Shape</tt> from a class to a Concept should not change the interpretation of how functions act on the object model. For example, consider the following definition in the Concepts TS<code>bool is_smaller(Shape &amp;l, Shape &amp;r) { return l.area() &lt; r.area(); }</code>
	If <tt>Shape</tt> is a base class, then <tt>is_smaller</tt> can compare the area of a triangle and a square, but if <tt>Shape</tt> is a Concept, it will only accept shapes of the same type. Changing from run-time dispatch to compile-time dispatch should be independent of the logical behavior of the function.</li>
<li><b>Protection against code breakage:</b>A <tt>constexpr</tt> function whose body is not capable of producing a constant expression will fail to compile whether or not it is ever called with constant arguments. Likewise, a function that is expected to be robust against whether its parameter type is a class or a Concept should only compile if it can handle both. For example, the following code is perfectly valid if <tt>Shape</tt> is a class, but will become badly broken if <tt>Shape</tt> is made into a Concept.
<code>bool is_convex(Shape &amp;s) 
{
  Shape s2 = s; <span class="comment">// Currently Ill-formed if Shape is a Concept</span>
  Shape s3;     <span class="comment">// Ill-formed if Shape is a Concept</span>
  vector&lt;Shape&gt; v; <span class="comment">// Ill-formed if Shape is a Concept</span>
  <span class="comment">/* ... */</span> }
}</code>
While perhaps we cannot expect perfection here, we would like to do better than that.</li>
</ol>
<p>In the rest of this paper, we look at how well several terse notation proposals support these goals. Our basic finding is that none of them are optimal on all of these goals &ldquo;as is&rdquo;. However, with some refinements, any one of the terse notations could provide excellent support all 3 goals. </p>
	
	
<h2>Concepts TS</h2>
<p>
<code>bool is_convex(Shape &amp;s); <span class="comment">// Valid with expected meaning whether Shape is a type or a Concept</span></code>
</p>
<p>However, even disregarding the independent concerns that have been raises by the committee about the Concepts TS terse notation, we contend that the Concepts TS does not provide very good flexibility between object-oriented and generic programming.</p>
<ul><li><b>Stable declarations:</b> This is the strong suit of the Concepts TS, as function declarations look the same whether or not they are used with classes or Concepts.
<code>bool is_convex(Shape &amp;s); <span class="comment">// Remains valid with expected meaning whether Shape is a type or a Concept</span></code></li>
	<li><b>Stable interpretations:</b>The interpretation of a declaration may depend on whether <tt>Shape</tt> is a base class or a Concept. For example, consider
<code>bool is_smaller(Shape &amp;l, Shape &amp;r) { return l.area() &lt; r.area(); }</code>
	If <tt>Shape</tt> is a base class, then <tt>is_smaller</tt> can compare the area of a triangle and a square, but if <tt>Shape</tt> is a Concept, it will only accept shapes of the same type.
</li>
	<li>Changing a base class to a Concept is likely to break the bodies of many templates as follows <code>bool is_convex(Shape &amp;s) 
{
  Shape s2 = s; <span class="comment">// OK with Concepts TS terse notation   (note 1)</span>
  Shape s3;     <span class="comment">// Ill-formed if Shape is a Concept     (note 2)</span>
  vector&lt;Shape&gt; v; <span class="comment">// Ill-formed if Shape is a Concept  (note 3)</span>
  <span class="comment">/* ... */</span>
}</code></li></ul>
<h3>Possible refinements</h3>
<p>In order to align the interpretation of object-oriented and generic functions, we believe it is desirable to allow the arguments to have independent types as long as they satisfy the requirements of the <tt>Shape</tt> concept. With this change, <tt>is_smaller</tt> could handle any two argumets that IsA shape. Indeed, straw polls have indicated that the committee prefers such independence as well (although we make no claims as to whether it is for similar reasons).</p>
<p>Unfortunately, we have no suggestions for improving the Concepts TS to better avoid &ldquo;body breakage&rdquo;</p>

<h2>A minimal solution to the concepts syntax problems</h2>
<p>Bjarne Stroustrup's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1079r0.pdf">A minimal solution to the concepts syntax problems</a> paper proposes that declarations using the natural syntax be preceded by the word <tt>template</tt>. As a result, making <tt>Shape</tt> a Concept will require modifying the declarations of all functions that use <tt>Shape</tt>. 
<code>template bool is_convex(Shape &amp;s); <span class="comment">// Shape must be a Concept</span></code>
	While this is easy to do for just the one function <tt>is_convex</tt>, tuning a library of functions may well become onerous (although still much better than without terse notation). Since arguments are resolved independently, there is no silent change in the interpretation of the declaration. The  proposal does not address questions of body breakage.</p>
<h3>Possible refinements</h3>
<p>One possible refinement is to allow any function declaration to be preceded by the word <tt>template</tt> if it has arguments that might become concepts. <code>template bool is_convex(Shape &amp;s); <span class="comment">// Permit whether Shape is a Concept or a class</span></code> Even if an object-oriented style is being currently used, this may be a useful declaration of intent. At the least, it would allow quick switching back and forth during the implementation phase. A keyword other than <tt>template</tt> may be worth considering as it is really a declaration that this may be (or become) either a function or a function template.</p>
<p>Again, we have no suggestions for mitigating potential body breakage.</p>
<h2>Concepts in-place syntax</h2>
<p>Herb Sutter's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0745r0.pdf">Concepts in-place syntax</a> proposal requires that changing <tt>Shape</tt> from a base class to a concept requires rewriting functions that accept <tt>Shape</tt>s.
<code>bool is_convex(Shape &amp;shape);   <span class="comment">// Shape is a class</span>
bool is_convex(Shape {} shape); <span class="comment">// Shape is a Concept</span></code>
While this is admittedly much less painful than the non-terse notation, it still means that a programmer who wants to compare compile-time and run-time dispatch may have to make changes in many places. Since different arguments </p><p>As mentioned above, if a class is replaced by a Concept that exposes the same logical interface, we would like to know that the code will at least still be syntactically valid.</p>
	 Conceptually, we are looking for something like template syntax checking, which has proven very useful, rather than something like C++0X concept definition checking.
</body></html>